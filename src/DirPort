or/addressmap.c:  const routerset_t *allow_nodes = options->ExitNodes;
or/addressmap.c:  const routerset_t *exclude_nodes = options->ExcludeExitNodesUnion_;
or/addressmap.c:  const smartlist_t *suffix_list = options->AutomapHostsSuffixes;
or/addressmap.c:  int clear_all = !options->AutomapHostsOnResolve;
or/addressmap.c:  const smartlist_t *suffixes = options->AutomapHostsSuffixes;
or/buffers.c:  if (! options->WarnUnsafeSocks)
or/circuitbuild.c:  if (!options->FastFirstHopPK)
or/circuitbuild.c:  if (options->UseNTorHandshake != -1)
or/circuitbuild.c:    return options->UseNTorHandshake;
or/circuitbuild.c:  if (options->PathBiasCircThreshold >= 5)
or/circuitbuild.c:    return options->PathBiasCircThreshold;
or/circuitbuild.c:  if (options->PathBiasNoticeRate >= 0.0)
or/circuitbuild.c:    return options->PathBiasNoticeRate;
or/circuitbuild.c:  if (options->PathBiasWarnRate >= 0.0)
or/circuitbuild.c:    return options->PathBiasWarnRate;
or/circuitbuild.c:  if (options->PathBiasExtremeRate >= 0.0)
or/circuitbuild.c:    return options->PathBiasExtremeRate;
or/circuitbuild.c:  if (options->PathBiasDropGuards >= 0)
or/circuitbuild.c:    return options->PathBiasDropGuards;
or/circuitbuild.c:  if (options->PathBiasScaleThreshold >= 10)
or/circuitbuild.c:    return options->PathBiasScaleThreshold;
or/circuitbuild.c:  if (options->PathBiasUseThreshold >= 3)
or/circuitbuild.c:    return options->PathBiasUseThreshold;
or/circuitbuild.c:  if (options->PathBiasNoticeUseRate >= 0.0)
or/circuitbuild.c:    return options->PathBiasNoticeUseRate;
or/circuitbuild.c:  if (options->PathBiasExtremeUseRate >= 0.0)
or/circuitbuild.c:    return options->PathBiasExtremeUseRate;
or/circuitbuild.c:  if (options->PathBiasScaleUseThreshold >= 10)
or/circuitbuild.c:    return options->PathBiasScaleUseThreshold;
or/circuitbuild.c:    if (routerset_contains_node(options->ExcludeExitNodesUnion_, node)) {
or/circuitbuild.c:    if (options->ExitNodes &&
or/circuitbuild.c:        !routerset_contains_node(options->ExitNodes, node)) {
or/circuitbuild.c:    if (!(node->is_valid || options->AllowInvalid_ & ALLOW_INVALID_EXIT)) {
or/circuitbuild.c:    if (options->ExcludeSingleHopRelays &&
or/circuitbuild.c:                 options->ExcludeExitNodesUnion_ ? " or are Excluded" : "");
or/circuitbuild.c:  if (options->ExitNodes) {
or/circuitbuild.c:             options->ExcludeExitNodesUnion_ ? "non-excluded " : "");
or/circuitbuild.c:      if (options->AllowInvalid_ & ALLOW_INVALID_MIDDLE)
or/circuitbuild.c:        return router_choose_random_node(NULL, options->ExcludeNodes, flags);
or/circuitbuild.c:      if (options->AllowInvalid_ & ALLOW_INVALID_RENDEZVOUS)
or/circuitbuild.c:      return router_choose_random_node(NULL, options->ExcludeNodes, flags);
or/circuitbuild.c:  routerset_t *rs = options->ExcludeNodes;
or/circuitbuild.c:      rs = options->ExcludeExitNodesUnion_;
or/circuitbuild.c:      rs = options->ExcludeExitNodesUnion_;
or/circuitbuild.c:    if (options->StrictNodes) {
or/circuitbuild.c:               rs==options->ExcludeNodes?"":" or ExcludeExitNodes",
or/circuitbuild.c:               rs==options->ExcludeNodes?"":" or ExcludeExitNodes",
or/circuitbuild.c:  if (options->AllowInvalid_ & ALLOW_INVALID_MIDDLE)
or/circuitbuild.c:  choice = router_choose_random_node(excluded, options->ExcludeNodes, flags);
or/circuitbuild.c:  if (state && options->UseEntryGuards &&
or/circuitbuild.c:      (purpose != CIRCUIT_PURPOSE_TESTING || options->BridgeRelay)) {
or/circuitbuild.c:  if (options->UseEntryGuards) {
or/circuitbuild.c:  if (options->AllowInvalid_ & ALLOW_INVALID_ENTRY)
or/circuitbuild.c:  choice = router_choose_random_node(excluded, options->ExcludeNodes, flags);
or/circuitlist.c:        if (options->ExcludeNodes) {
or/circuitlist.c:            if (routerset_contains_extendinfo(options->ExcludeNodes,
or/circuitmux_ewma.c:  if (options && options->CircuitPriorityHalflife >= -EPSILON) {
or/circuitmux_ewma.c:    halflife = options->CircuitPriorityHalflife;
or/circuituse.c:    if (routerset_contains_extendinfo(options->ExcludeNodes,
or/circuituse.c:  if (routerset_contains_extendinfo(options->ExcludeExitNodes,
or/circuituse.c:  SET_CUTOFF(stream_cutoff, MAX(options->CircuitStreamTimeout,15)*1000 + 1000);
or/circuituse.c:                 options->CircuitStreamTimeout * 1000) + 1000);
or/circuituse.c:                 options->SocksTimeout * 1000));
or/circuituse.c:    if (!(options->CloseHSClientCircuitsImmediatelyOnTimeout) &&
or/circuituse.c:    if (!(options->CloseHSServiceRendCircuitsImmediatelyOnTimeout) &&
or/circuituse.c:    time_to_new_circuit = now + options->NewCircuitPeriod;
or/circuituse.c:  if (!options->DisablePredictedCircuits)
or/circuituse.c:                smartlist_contains_int_as_string(options->LongLivedPorts,
or/circuituse.c:               options->UseBridges ? "bridges" : "entrynodes");
or/circuituse.c:      } else if (!options->UseBridges || any_bridge_descriptors_known()) {
or/circuituse.c:    if (n_pending >= options->MaxClientCircuitsPending) {
or/circuituse.c:    if (options->Tor2webMode &&
or/circuituse.c:  if (options->OptimisticData < 0) {
or/circuituse.c:  return options->OptimisticData;
or/circuituse.c:  if (!options->TrackHostExits)
or/circuituse.c:  SMARTLIST_FOREACH_BEGIN(options->TrackHostExits, const char *, cp) {
or/circuituse.c:  if (!options->TrackHostExits ||
or/circuituse.c:                              options->TrackHostExitsExpire))
or/circuituse.c:                      time(NULL) + options->TrackHostExitsExpire,
or/circuituse.c:  if (options->MaxCircuitDirtiness >= circ->base_.timestamp_dirty)
or/circuituse.c:    circ->base_.timestamp_dirty -= options->MaxCircuitDirtiness;
or/config.c:  routerset_free(options->ExcludeExitNodesUnion_);
or/config.c:  if (options->NodeFamilySets) {
or/config.c:    SMARTLIST_FOREACH(options->NodeFamilySets, routerset_t *,
or/config.c:    smartlist_free(options->NodeFamilySets);
or/config.c:  tor_free(options->BridgePassword_AuthDigest_);
or/config.c: * a client -- safe to log according to the settings in options->SafeLogging,
or/config.c: * -- safe to log according to the settings in options->SafeLogging, and
or/config.c:  if (options->DirAuthorities &&
or/config.c:      (options->AlternateDirAuthority || options->AlternateBridgeAuthority ||
or/config.c:       options->AlternateHSAuthority)) {
or/config.c:  if ((options->DirAuthorities &&
or/config.c:        !config_lines_eq(options->DirAuthorities,
or/config.c:                         old_options->DirAuthorities))) ||
or/config.c:      (options->AlternateDirAuthority &&
or/config.c:        !config_lines_eq(options->AlternateDirAuthority,
or/config.c:                         old_options->AlternateDirAuthority)))) {
or/config.c:  for (cl = options->DirAuthorities; cl; cl = cl->next)
or/config.c:  for (cl = options->AlternateBridgeAuthority; cl; cl = cl->next)
or/config.c:  for (cl = options->AlternateDirAuthority; cl; cl = cl->next)
or/config.c:  for (cl = options->AlternateHSAuthority; cl; cl = cl->next)
or/config.c:  for (cl = options->FallbackDir; cl; cl = cl->next)
or/config.c:    !config_lines_eq(options->DirAuthorities, old_options->DirAuthorities) ||
or/config.c:    !config_lines_eq(options->FallbackDir, old_options->FallbackDir) ||
or/config.c:    !config_lines_eq(options->AlternateBridgeAuthority,
or/config.c:                     old_options->AlternateBridgeAuthority) ||
or/config.c:    !config_lines_eq(options->AlternateDirAuthority,
or/config.c:                     old_options->AlternateDirAuthority) ||
or/config.c:    !config_lines_eq(options->AlternateHSAuthority,
or/config.c:                     old_options->AlternateHSAuthority);
or/config.c:  if (!options->DirAuthorities) {
or/config.c:    if (!options->AlternateBridgeAuthority)
or/config.c:    if (!options->AlternateDirAuthority)
or/config.c:    if (!options->AlternateHSAuthority)
or/config.c:  if (!options->FallbackDir)
or/config.c:  for (cl = options->DirAuthorities; cl; cl = cl->next)
or/config.c:  for (cl = options->AlternateBridgeAuthority; cl; cl = cl->next)
or/config.c:  for (cl = options->AlternateDirAuthority; cl; cl = cl->next)
or/config.c:  for (cl = options->AlternateHSAuthority; cl; cl = cl->next)
or/config.c:  for (cl = options->FallbackDir; cl; cl = cl->next)
or/config.c:  int running_tor = options->command == CMD_RUN_TOR;
or/config.c:  if (running_tor && options->RunAsDaemon) {
or/config.c:  if (options->ControlSocket || options->ControlSocketsGroupWritable) {
or/config.c:  if (options->ControlSocketsGroupWritable && !options->ControlSocket) {
or/config.c:    if (set_max_file_descriptors((unsigned)options->ConnLimit,
or/config.c:                                 &options->ConnLimit_) < 0) {
or/config.c:                              options->DisableNetwork) < 0) {
or/config.c:    if (options->DisableNetwork) {
or/config.c:  if (options->TransPort_set) {
or/config.c:  if (options->DisableAllSwap) {
or/config.c:  if (options->User) {
or/config.c:    if (switch_id(options->User) != 0) {
or/config.c:  if (check_private_dir(options->DataDirectory,
or/config.c:                        options->User)<0) {
or/config.c:              options->DataDirectory);
or/config.c:                 options->DataDirectory);
or/config.c:                          options->User) < 0) {
or/config.c:    set_max_file_descriptors((unsigned)old_options->ConnLimit,
or/config.c:                             &options->ConnLimit_);
or/config.c:    options->BridgeRelay && options->BridgeRecordUsageByCountry;
or/config.c:    routerset_needs_geoip(options->EntryNodes) ||
or/config.c:    routerset_needs_geoip(options->ExitNodes) ||
or/config.c:    routerset_needs_geoip(options->ExcludeExitNodes) ||
or/config.c:    routerset_needs_geoip(options->ExcludeNodes);
or/config.c:  uint64_t bw = options->BandwidthRate;
or/config.c:  if (bw > options->MaxAdvertisedBandwidth)
or/config.c:    bw = options->MaxAdvertisedBandwidth;
or/config.c:  if (options->RelayBandwidthRate > 0 && bw > options->RelayBandwidthRate)
or/config.c:    bw = options->RelayBandwidthRate;
or/config.c:  uint64_t bw = options->BandwidthBurst;
or/config.c:  if (options->RelayBandwidthBurst > 0 && bw > options->RelayBandwidthBurst)
or/config.c:    bw = options->RelayBandwidthBurst;
or/config.c:  if ((old_options->DynamicDHGroups != new_options->DynamicDHGroups)) {
or/config.c:  if (!opt_streq(old_options->TLSECGroup, new_options->TLSECGroup))
or/config.c:  int running_tor = options->command == CMD_RUN_TOR;
or/config.c:    if (options->DisableDebuggerAttachment && !disabled_debugger_attach &&
or/config.c:    } else if (!options->DisableDebuggerAttachment &&
or/config.c:  if (!options->Tor2webMode) {
or/config.c:  if (options->Tor2webMode) {
or/config.c:  if (options->SafeLogging_ != SAFELOG_SCRUB_ALL &&
or/config.c:      (!old_options || old_options->SafeLogging_ != options->SafeLogging_)) {
or/config.c:  if (options->Bridges) {
or/config.c:    for (cl = options->Bridges; cl; cl = cl->next) {
or/config.c:  if (options->ClientTransportPlugin) {
or/config.c:    for (cl = options->ClientTransportPlugin; cl; cl = cl->next) {
or/config.c:  if (options->ServerTransportPlugin && server_mode(options)) {
or/config.c:    for (cl = options->ServerTransportPlugin; cl; cl = cl->next) {
or/config.c:  if (options->RunAsDaemon) {
or/config.c:    finish_daemon(options->DataDirectory);
or/config.c:  if (server_mode(options) && options->DynamicDHGroups) {
or/config.c:    if (check_private_dir(keydir, CPD_CREATE, options->User)) {
or/config.c:    if (!old_options || !old_options->DynamicDHGroups) {
or/config.c:      (options->V3AuthoritativeDir && (!old_options ||
or/config.c:                                       !old_options->V3AuthoritativeDir))) {
or/config.c:  if (options->PidFile)
or/config.c:    write_pidfile(options->PidFile);
or/config.c:  parse_virtual_addr_network(options->VirtualAddrNetworkIPv4, AF_INET,0,NULL);
or/config.c:  parse_virtual_addr_network(options->VirtualAddrNetworkIPv6, AF_INET6,0,NULL);
or/config.c:  if (init_control_cookie_authentication(options->CookieAuthentication) < 0) {
or/config.c:  if (init_ext_or_cookie_authentication(!!options->ExtORPort_lines) < 0) {
or/config.c:  monitor_owning_controller_process(options->OwningControllerProcess);
or/config.c:      old_options->BandwidthRate != options->BandwidthRate ||
or/config.c:      old_options->BandwidthBurst != options->BandwidthBurst ||
or/config.c:      old_options->RelayBandwidthRate != options->RelayBandwidthRate ||
or/config.c:      old_options->RelayBandwidthBurst != options->RelayBandwidthBurst)
or/config.c:  if (options->BridgePassword) {
or/config.c:    http_authenticator = alloc_http_authenticator(options->BridgePassword);
or/config.c:    options->BridgePassword_AuthDigest_ = tor_malloc(DIGEST256_LEN);
or/config.c:    crypto_digest256(options->BridgePassword_AuthDigest_,
or/config.c:    if ((options->UseEntryGuards && !old_options->UseEntryGuards) ||
or/config.c:        options->UseBridges != old_options->UseBridges ||
or/config.c:        (options->UseBridges &&
or/config.c:         !config_lines_eq(options->Bridges, old_options->Bridges)) ||
or/config.c:        !routerset_equal(old_options->ExcludeNodes,options->ExcludeNodes) ||
or/config.c:        !routerset_equal(old_options->ExcludeExitNodes,
or/config.c:                         options->ExcludeExitNodes) ||
or/config.c:        !routerset_equal(old_options->EntryNodes, options->EntryNodes) ||
or/config.c:        !routerset_equal(old_options->ExitNodes, options->ExitNodes) ||
or/config.c:        options->StrictNodes != old_options->StrictNodes) {
or/config.c:    if (!smartlist_strings_eq(old_options->TrackHostExits,
or/config.c:                              options->TrackHostExits))
or/config.c:    if (!options->AutomapHostsOnResolve) {
or/config.c:      if (old_options->AutomapHostsOnResolve)
or/config.c:      if (!smartlist_strings_eq(old_options->AutomapHostsSuffixes,
or/config.c:                                options->AutomapHostsSuffixes))
or/config.c:      else if (!opt_streq(old_options->VirtualAddrNetworkIPv4,
or/config.c:                          options->VirtualAddrNetworkIPv4) ||
or/config.c:               !opt_streq(old_options->VirtualAddrNetworkIPv6,
or/config.c:                          options->VirtualAddrNetworkIPv6))
or/config.c:    if (! bool_eq(options->BridgeRelay, old_options->BridgeRelay)) {
or/config.c:      if (options->BridgeRelay) {
or/config.c:        if (config_lines_eq(old_options->ORPort_lines,options->ORPort_lines)) {
or/config.c:    if (options->PerConnBWRate != old_options->PerConnBWRate ||
or/config.c:        options->PerConnBWBurst != old_options->PerConnBWBurst)
or/config.c:  if (geoip_is_loaded(AF_INET) && options->GeoIPExcludeUnknown) {
or/config.c:    const int is_auto = options->GeoIPExcludeUnknown == -1;
or/config.c:    changed  = routerset_add_unknown_ccs(&options->ExcludeNodes, is_auto);
or/config.c:    changed += routerset_add_unknown_ccs(&options->ExcludeExitNodes, is_auto);
or/config.c:      routerset_add_unknown_ccs(&options->ExcludeExitNodesUnion_, is_auto);
or/config.c:  if (options->CellStatistics || options->DirReqStatistics ||
or/config.c:      options->EntryStatistics || options->ExitPortStatistics ||
or/config.c:      options->ConnDirectionStatistics ||
or/config.c:      options->BridgeAuthoritativeDir) {
or/config.c:      options->CellStatistics = 0;
or/config.c:      options->DirReqStatistics = 0;
or/config.c:      options->EntryStatistics = 0;
or/config.c:      options->ExitPortStatistics = 0;
or/config.c:    if ((!old_options || !old_options->CellStatistics) &&
or/config.c:        options->CellStatistics) {
or/config.c:    if ((!old_options || !old_options->DirReqStatistics) &&
or/config.c:        options->DirReqStatistics) {
or/config.c:        options->DirReqStatistics = 0;
or/config.c:        if (options->ORPort_set)
or/config.c:    if ((!old_options || !old_options->EntryStatistics) &&
or/config.c:        options->EntryStatistics && !should_record_bridge_info(options)) {
or/config.c:        options->EntryStatistics = 0;
or/config.c:    if ((!old_options || !old_options->ExitPortStatistics) &&
or/config.c:        options->ExitPortStatistics) {
or/config.c:    if ((!old_options || !old_options->ConnDirectionStatistics) &&
or/config.c:        options->ConnDirectionStatistics) {
or/config.c:    if ((!old_options || !old_options->BridgeAuthoritativeDir) &&
or/config.c:        options->BridgeAuthoritativeDir) {
or/config.c:  if (old_options && old_options->CellStatistics &&
or/config.c:      !options->CellStatistics)
or/config.c:  if (old_options && old_options->DirReqStatistics &&
or/config.c:      !options->DirReqStatistics)
or/config.c:  if (old_options && old_options->EntryStatistics &&
or/config.c:      !options->EntryStatistics)
or/config.c:  if (old_options && old_options->ExitPortStatistics &&
or/config.c:      !options->ExitPortStatistics)
or/config.c:  if (old_options && old_options->ConnDirectionStatistics &&
or/config.c:      !options->ConnDirectionStatistics)
or/config.c:  if (old_options && old_options->BridgeAuthoritativeDir &&
or/config.c:      !options->BridgeAuthoritativeDir)
or/config.c:  if (options->EntryNodes &&
or/config.c:       !routerset_equal(old_options->EntryNodes,options->EntryNodes) ||
or/config.c:       !routerset_equal(old_options->ExcludeNodes,options->ExcludeNodes)))
or/config.c:  if (options->DirPortFrontPage) {
or/config.c:      read_file_to_str(options->DirPortFrontPage, 0, NULL);
or/config.c:               options->DirPortFrontPage);
or/config.c: * Use <b>options-\>Address</b> to guess our public IP address.
or/config.c:  const char *address = options->Address;
or/config.c:    if (!options->DirAuthorities && !options->AlternateDirAuthority) {
or/config.c:  smartlist_t *list = options->PublishServerDescriptor;
or/config.c:  dirinfo_type_t *auth = &options->PublishServerDescriptor_;
or/config.c:      if (options->BridgeRelay)
or/config.c:  if (options->Nickname == NULL) {
or/config.c:        options->Nickname = tor_strdup(UNNAMED_ROUTER_NICKNAME);
or/config.c:    if (!is_legal_nickname(options->Nickname)) {
or/config.c:          options->Nickname);
or/config.c:  if (server_mode(options) && !options->ContactInfo)
or/config.c:  if (!options->Logs && !options->RunAsDaemon && !from_setconf) {
or/config.c:        config_line_append(&options->Logs, "Log", "notice stdout");
or/config.c:        config_line_append(&options->Logs, "Log", "warn stdout");
or/config.c:  if (options->RunAsDaemon && torrc_fname && path_is_relative(torrc_fname))
or/config.c:  if (n_ports == 0 && !options->RendConfigLines)
or/config.c:  if (options->TransPort_set || options->TransListenAddress)
or/config.c:  if (options->TokenBucketRefillInterval <= 0
or/config.c:      || options->TokenBucketRefillInterval > 1000) {
or/config.c:  if (options->DisableV2DirectoryInfo_ && ! authdir_mode(options)) {
or/config.c:  if (options->ExcludeExitNodes || options->ExcludeNodes) {
or/config.c:    options->ExcludeExitNodesUnion_ = routerset_new();
or/config.c:    routerset_union(options->ExcludeExitNodesUnion_,options->ExcludeExitNodes);
or/config.c:    routerset_union(options->ExcludeExitNodesUnion_,options->ExcludeNodes);
or/config.c:  if (options->NodeFamilies) {
or/config.c:    options->NodeFamilySets = smartlist_new();
or/config.c:    for (cl = options->NodeFamilies; cl; cl = cl->next) {
or/config.c:        smartlist_add(options->NodeFamilySets, rs);
or/config.c:  if (options->TLSECGroup && (strcasecmp(options->TLSECGroup, "P256") &&
or/config.c:                              strcasecmp(options->TLSECGroup, "P224"))) {
or/config.c:    tor_free(options->TLSECGroup);
or/config.c:  if (options->ExcludeNodes && options->StrictNodes) {
or/config.c:  if (options->AuthoritativeDir) {
or/config.c:    if (!options->ContactInfo && !options->TestingTorNetwork)
or/config.c:    if (options->V1AuthoritativeDir && !options->RecommendedVersions)
or/config.c:    if (!options->RecommendedClientVersions)
or/config.c:      options->RecommendedClientVersions =
or/config.c:        config_lines_dup(options->RecommendedVersions);
or/config.c:    if (!options->RecommendedServerVersions)
or/config.c:      options->RecommendedServerVersions =
or/config.c:        config_lines_dup(options->RecommendedVersions);
or/config.c:    if (options->VersioningAuthoritativeDir &&
or/config.c:        (!options->RecommendedClientVersions ||
or/config.c:         !options->RecommendedServerVersions))
or/config.c:    if (options->UseEntryGuards) {
or/config.c:      options->UseEntryGuards = 0;
or/config.c:    if (!options->DownloadExtraInfo && authdir_mode_any_main(options)) {
or/config.c:      options->DownloadExtraInfo = 1;
or/config.c:    if (!(options->BridgeAuthoritativeDir || options->HSAuthoritativeDir ||
or/config.c:          options->V1AuthoritativeDir || options->V2AuthoritativeDir ||
or/config.c:          options->V3AuthoritativeDir))
or/config.c:    if (options->V3BandwidthsFile && !old_options) {
or/config.c:      dirserv_read_measured_bandwidths(options->V3BandwidthsFile, NULL);
or/config.c:  if (options->AuthoritativeDir && !options->DirPort_set)
or/config.c:  if (options->AuthoritativeDir && !options->ORPort_set)
or/config.c:  if (options->AuthoritativeDir && options->ClientOnly)
or/config.c:  if (options->FetchDirInfoExtraEarly && !options->FetchDirInfoEarly)
or/config.c:  if (options->HSAuthoritativeDir && proxy_mode(options))
or/config.c:  if (options->ConnLimit <= 0) {
or/config.c:        options->ConnLimit);
or/config.c:  if (options->PathsNeededToBuildCircuits >= 0.0) {
or/config.c:    if (options->PathsNeededToBuildCircuits < 0.25) {
or/config.c:      options->PathsNeededToBuildCircuits = 0.25;
or/config.c:    } else if (options->PathsNeededToBuildCircuits > 0.95) {
or/config.c:      options->PathsNeededToBuildCircuits = 0.95;
or/config.c:  if (options->MaxClientCircuitsPending <= 0 ||
or/config.c:      options->MaxClientCircuitsPending > MAX_MAX_CLIENT_CIRCUITS_PENDING) {
or/config.c:                 options->MaxClientCircuitsPending);
or/config.c:  if (validate_ports_csv(options->FirewallPorts, "FirewallPorts", msg) < 0)
or/config.c:  if (validate_ports_csv(options->LongLivedPorts, "LongLivedPorts", msg) < 0)
or/config.c:  if (validate_ports_csv(options->RejectPlaintextPorts,
or/config.c:  if (validate_ports_csv(options->WarnPlaintextPorts,
or/config.c:  if (options->FascistFirewall && !options->ReachableAddresses) {
or/config.c:    if (options->FirewallPorts && smartlist_len(options->FirewallPorts)) {
or/config.c:      SMARTLIST_FOREACH(options->FirewallPorts, const char *, portno,
or/config.c:      options->ReachableAddresses = new_line;
or/config.c:      if (!options->ReachableDirAddresses) {
or/config.c:        options->ReachableDirAddresses = new_line;
or/config.c:      if (!options->ReachableORAddresses) {
or/config.c:        options->ReachableORAddresses = new_line;
or/config.c:      (i==0) ? &options->ReachableAddresses :
or/config.c:        (i==1) ? &options->ReachableORAddresses :
or/config.c:                 &options->ReachableDirAddresses;
or/config.c:  if ((options->ReachableAddresses ||
or/config.c:       options->ReachableORAddresses ||
or/config.c:       options->ReachableDirAddresses) &&
or/config.c:  if (options->UseBridges &&
or/config.c:  if (options->UseBridges && options->EntryNodes)
or/config.c:  if (options->EntryNodes && !options->UseEntryGuards) {
or/config.c:  if (options->MaxMemInCellQueues < (500 << 20)) {
or/config.c:    options->MaxMemInCellQueues = (500 << 20);
or/config.c:  options->AllowInvalid_ = 0;
or/config.c:  if (options->AllowInvalidNodes) {
or/config.c:    SMARTLIST_FOREACH_BEGIN(options->AllowInvalidNodes, const char *, cp) {
or/config.c:          options->AllowInvalid_ |= ALLOW_INVALID_ENTRY;
or/config.c:          options->AllowInvalid_ |= ALLOW_INVALID_EXIT;
or/config.c:          options->AllowInvalid_ |= ALLOW_INVALID_MIDDLE;
or/config.c:          options->AllowInvalid_ |= ALLOW_INVALID_INTRODUCTION;
or/config.c:          options->AllowInvalid_ |= ALLOW_INVALID_RENDEZVOUS;
or/config.c:  if (!options->SafeLogging ||
or/config.c:      !strcasecmp(options->SafeLogging, "0")) {
or/config.c:    options->SafeLogging_ = SAFELOG_SCRUB_NONE;
or/config.c:  } else if (!strcasecmp(options->SafeLogging, "relay")) {
or/config.c:    options->SafeLogging_ = SAFELOG_SCRUB_RELAY;
or/config.c:  } else if (!strcasecmp(options->SafeLogging, "1")) {
or/config.c:    options->SafeLogging_ = SAFELOG_SCRUB_ALL;
or/config.c:                     escaped(options->SafeLogging));
or/config.c:  if ((options->BridgeRelay
or/config.c:        || options->PublishServerDescriptor_ & BRIDGE_DIRINFO)
or/config.c:      && (options->PublishServerDescriptor_
or/config.c:  if (options->BridgeRelay && options->DirPort_set) {
or/config.c:    config_free_lines(options->DirPort_lines);
or/config.c:    options->DirPort_lines = NULL;
or/config.c:    options->DirPort_set = 0;
or/config.c:  if (options->MinUptimeHidServDirectoryV2 < 0) {
or/config.c:    options->MinUptimeHidServDirectoryV2 = 0;
or/config.c:  if (options->RendPostPeriod < MIN_REND_POST_PERIOD) {
or/config.c:    options->RendPostPeriod = MIN_REND_POST_PERIOD;
or/config.c:  if (options->RendPostPeriod > MAX_DIR_PERIOD) {
or/config.c:    options->RendPostPeriod = MAX_DIR_PERIOD;
or/config.c:  if (options->Tor2webMode && options->LearnCircuitBuildTimeout) {
or/config.c:    options->LearnCircuitBuildTimeout = 0;
or/config.c:  if (options->Tor2webMode && options->UseEntryGuards) {
or/config.c:    options->UseEntryGuards = 0;
or/config.c:  if (!(options->UseEntryGuards) &&
or/config.c:      (options->RendConfigLines != NULL)) {
or/config.c:  if (!options->LearnCircuitBuildTimeout && options->CircuitBuildTimeout &&
or/config.c:      options->CircuitBuildTimeout < RECOMMENDED_MIN_CIRCUIT_BUILD_TIMEOUT) {
or/config.c:        options->CircuitBuildTimeout,
or/config.c:  } else if (!options->LearnCircuitBuildTimeout &&
or/config.c:             !options->CircuitBuildTimeout) {
or/config.c:  if (options->PathBiasNoticeRate > 1.0) {
or/config.c:  if (options->PathBiasWarnRate > 1.0) {
or/config.c:  if (options->PathBiasExtremeRate > 1.0) {
or/config.c:  if (options->PathBiasNoticeUseRate > 1.0) {
or/config.c:  if (options->PathBiasExtremeUseRate > 1.0) {
or/config.c:  if (options->MaxCircuitDirtiness < MIN_MAX_CIRCUIT_DIRTINESS) {
or/config.c:    options->MaxCircuitDirtiness = MIN_MAX_CIRCUIT_DIRTINESS;
or/config.c:  if (options->CircuitStreamTimeout &&
or/config.c:      options->CircuitStreamTimeout < MIN_CIRCUIT_STREAM_TIMEOUT) {
or/config.c:    options->CircuitStreamTimeout = MIN_CIRCUIT_STREAM_TIMEOUT;
or/config.c:  if (options->HeartbeatPeriod &&
or/config.c:      options->HeartbeatPeriod < MIN_HEARTBEAT_PERIOD) {
or/config.c:    options->HeartbeatPeriod = MIN_HEARTBEAT_PERIOD;
or/config.c:  if (options->KeepalivePeriod < 1)
or/config.c:  if (ensure_bandwidth_cap(&options->BandwidthRate,
or/config.c:  if (ensure_bandwidth_cap(&options->BandwidthBurst,
or/config.c:  if (ensure_bandwidth_cap(&options->MaxAdvertisedBandwidth,
or/config.c:  if (ensure_bandwidth_cap(&options->RelayBandwidthRate,
or/config.c:  if (ensure_bandwidth_cap(&options->RelayBandwidthBurst,
or/config.c:  if (ensure_bandwidth_cap(&options->PerConnBWRate,
or/config.c:  if (ensure_bandwidth_cap(&options->PerConnBWBurst,
or/config.c:  if (ensure_bandwidth_cap(&options->AuthDirFastGuarantee,
or/config.c:  if (ensure_bandwidth_cap(&options->AuthDirGuardBWGuarantee,
or/config.c:  if (options->RelayBandwidthRate && !options->RelayBandwidthBurst)
or/config.c:    options->RelayBandwidthBurst = options->RelayBandwidthRate;
or/config.c:  if (options->RelayBandwidthBurst && !options->RelayBandwidthRate)
or/config.c:    options->RelayBandwidthRate = options->RelayBandwidthBurst;
or/config.c:    if (options->BandwidthRate < ROUTER_REQUIRED_MIN_BANDWIDTH) {
or/config.c:                       (int)options->BandwidthRate,
or/config.c:    } else if (options->MaxAdvertisedBandwidth <
or/config.c:                       (int)options->MaxAdvertisedBandwidth,
or/config.c:    if (options->RelayBandwidthRate &&
or/config.c:      options->RelayBandwidthRate < ROUTER_REQUIRED_MIN_BANDWIDTH) {
or/config.c:                       (int)options->RelayBandwidthRate,
or/config.c:  if (options->RelayBandwidthRate > options->RelayBandwidthBurst)
or/config.c:  if (options->BandwidthRate > options->BandwidthBurst)
or/config.c:  if (options->RelayBandwidthRate > options->BandwidthRate)
or/config.c:    options->BandwidthRate = options->RelayBandwidthRate;
or/config.c:  if (options->RelayBandwidthBurst > options->BandwidthBurst)
or/config.c:    options->BandwidthBurst = options->RelayBandwidthBurst;
or/config.c:  if (options->AccountingMax) {
or/config.c:    if (options->RendConfigLines && server_mode(options)) {
or/config.c:    } else if (config_count_key(options->RendConfigLines,
or/config.c:  if (options->HTTPProxy) { /* parse it now */
or/config.c:    if (tor_addr_port_lookup(options->HTTPProxy,
or/config.c:                        &options->HTTPProxyAddr, &options->HTTPProxyPort) < 0)
or/config.c:    if (options->HTTPProxyPort == 0) { /* give it a default */
or/config.c:      options->HTTPProxyPort = 80;
or/config.c:  if (options->HTTPProxyAuthenticator) {
or/config.c:    if (strlen(options->HTTPProxyAuthenticator) >= 512)
or/config.c:  if (options->HTTPSProxy) { /* parse it now */
or/config.c:    if (tor_addr_port_lookup(options->HTTPSProxy,
or/config.c:                        &options->HTTPSProxyAddr, &options->HTTPSProxyPort) <0)
or/config.c:    if (options->HTTPSProxyPort == 0) { /* give it a default */
or/config.c:      options->HTTPSProxyPort = 443;
or/config.c:  if (options->HTTPSProxyAuthenticator) {
or/config.c:    if (strlen(options->HTTPSProxyAuthenticator) >= 512)
or/config.c:  if (options->Socks4Proxy) { /* parse it now */
or/config.c:    if (tor_addr_port_lookup(options->Socks4Proxy,
or/config.c:                        &options->Socks4ProxyAddr,
or/config.c:                        &options->Socks4ProxyPort) <0)
or/config.c:    if (options->Socks4ProxyPort == 0) { /* give it a default */
or/config.c:      options->Socks4ProxyPort = 1080;
or/config.c:  if (options->Socks5Proxy) { /* parse it now */
or/config.c:    if (tor_addr_port_lookup(options->Socks5Proxy,
or/config.c:                            &options->Socks5ProxyAddr,
or/config.c:                            &options->Socks5ProxyPort) <0)
or/config.c:    if (options->Socks5ProxyPort == 0) { /* give it a default */
or/config.c:      options->Socks5ProxyPort = 1080;
or/config.c:  if (!!options->Socks4Proxy + !!options->Socks5Proxy +
or/config.c:      !!options->HTTPSProxy + !!options->ClientTransportPlugin > 1)
or/config.c:  if (options->HTTPProxy && !(options->Socks4Proxy ||
or/config.c:                              options->Socks5Proxy ||
or/config.c:                              options->HTTPSProxy)) {
or/config.c:  if (options->Socks5ProxyUsername) {
or/config.c:    len = strlen(options->Socks5ProxyUsername);
or/config.c:    if (!options->Socks5ProxyPassword)
or/config.c:    len = strlen(options->Socks5ProxyPassword);
or/config.c:  } else if (options->Socks5ProxyPassword)
or/config.c:  if (options->HashedControlPassword) {
or/config.c:    smartlist_t *sl = decode_hashed_passwords(options->HashedControlPassword);
or/config.c:  if (options->HashedControlSessionPassword) {
or/config.c:                                  options->HashedControlSessionPassword);
or/config.c:  if (options->OwningControllerProcess) {
or/config.c:    if (tor_validate_process_specifier(options->OwningControllerProcess,
or/config.c:  if (options->ControlPort_set && !options->HashedControlPassword &&
or/config.c:      !options->HashedControlSessionPassword &&
or/config.c:      !options->CookieAuthentication) {
or/config.c:  if (options->CookieAuthFileGroupReadable && !options->CookieAuthFile) {
or/config.c:  if (options->UseEntryGuards && ! options->NumEntryGuards)
or/config.c:  if (options->MyFamily && options->BridgeRelay) {
or/config.c:  if (check_nickname_list(options->MyFamily, "MyFamily", msg))
or/config.c:  for (cl = options->NodeFamilies; cl; cl = cl->next) {
or/config.c:  if (options->UseBridges && !options->Bridges)
or/config.c:  if (options->UseBridges && !options->TunnelDirConns)
or/config.c:  for (cl = options->Bridges; cl; cl = cl->next) {
or/config.c:  for (cl = options->ClientTransportPlugin; cl; cl = cl->next) {
or/config.c:  for (cl = options->ServerTransportPlugin; cl; cl = cl->next) {
or/config.c:  if (options->ServerTransportPlugin && !server_mode(options)) {
or/config.c:               escaped(options->ServerTransportPlugin->value));
or/config.c:  for (cl = options->ServerTransportListenAddr; cl; cl = cl->next) {
or/config.c:  if (options->ServerTransportListenAddr && !options->ServerTransportPlugin) {
or/config.c:  for (cl = options->ServerTransportOptions; cl; cl = cl->next) {
or/config.c:  if (options->ConstrainedSockets) {
or/config.c:    if (options->ConstrainedSockSize < MIN_CONSTRAINED_TCP_BUFFER ||
or/config.c:        options->ConstrainedSockSize > MAX_CONSTRAINED_TCP_BUFFER ||
or/config.c:        options->ConstrainedSockSize % 1024) {
or/config.c:    if (options->DirPort_set) {
or/config.c:  if (options->V3AuthVoteDelay + options->V3AuthDistDelay >=
or/config.c:      options->V3AuthVotingInterval/2) {
or/config.c:  if (options->V3AuthVoteDelay < MIN_VOTE_SECONDS)
or/config.c:  if (options->V3AuthDistDelay < MIN_DIST_SECONDS)
or/config.c:  if (options->V3AuthNIntervalsValid < 2)
or/config.c:  if (options->V3AuthVotingInterval < MIN_VOTE_INTERVAL) {
or/config.c:  } else if (options->V3AuthVotingInterval > 24*60*60) {
or/config.c:  } else if (((24*60*60) % options->V3AuthVotingInterval) != 0) {
or/config.c:  if (parse_virtual_addr_network(options->VirtualAddrNetworkIPv4,
or/config.c:  if (parse_virtual_addr_network(options->VirtualAddrNetworkIPv6,
or/config.c:  if (options->PreferTunneledDirConns && !options->TunnelDirConns)
or/config.c:  if ((options->Socks4Proxy || options->Socks5Proxy) &&
or/config.c:      !options->HTTPProxy && !options->PreferTunneledDirConns)
or/config.c:  if (options->AutomapHostsSuffixes) {
or/config.c:    SMARTLIST_FOREACH(options->AutomapHostsSuffixes, char *, suf,
or/config.c:  if (options->TestingTorNetwork &&
or/config.c:      !(options->DirAuthorities ||
or/config.c:        (options->AlternateDirAuthority &&
or/config.c:         options->AlternateBridgeAuthority))) {
or/config.c:  if (options->AllowSingleHopExits && !options->DirAuthorities) {
or/config.c:    if (!options->TestingTorNetwork &&                                  \
or/config.c:        !options->UsingTestNetworkDefaults_ &&                          \
or/config.c:  if (options->TestingV3AuthInitialVotingInterval < MIN_VOTE_INTERVAL) {
or/config.c:  } else if (((30*60) % options->TestingV3AuthInitialVotingInterval) != 0) {
or/config.c:  if (options->TestingV3AuthInitialVoteDelay < MIN_VOTE_SECONDS) {
or/config.c:  if (options->TestingV3AuthInitialDistDelay < MIN_DIST_SECONDS) {
or/config.c:  if (options->TestingV3AuthInitialVoteDelay +
or/config.c:      options->TestingV3AuthInitialDistDelay >=
or/config.c:      options->TestingV3AuthInitialVotingInterval/2) {
or/config.c:  if (options->TestingV3AuthVotingStartOffset >
or/config.c:      MIN(options->TestingV3AuthInitialVotingInterval,
or/config.c:          options->V3AuthVotingInterval)) {
or/config.c:  if (options->TestingAuthDirTimeToLearnReachability < 0) {
or/config.c:  } else if (options->TestingAuthDirTimeToLearnReachability > 2*60*60) {
or/config.c:  if (options->TestingEstimatedDescriptorPropagationTime < 0) {
or/config.c:  } else if (options->TestingEstimatedDescriptorPropagationTime > 60*60) {
or/config.c:  if (options->TestingClientMaxIntervalWithoutRequest < 1) {
or/config.c:  } else if (options->TestingClientMaxIntervalWithoutRequest > 3600) {
or/config.c:  if (options->TestingDirConnectionMaxStall < 5) {
or/config.c:  } else if (options->TestingDirConnectionMaxStall > 3600) {
or/config.c:  if (options->TestingConsensusMaxDownloadTries < 2) {
or/config.c:  } else if (options->TestingConsensusMaxDownloadTries > 800) {
or/config.c:  if (options->TestingDescriptorMaxDownloadTries < 2) {
or/config.c:  } else if (options->TestingDescriptorMaxDownloadTries > 800) {
or/config.c:  if (options->TestingMicrodescMaxDownloadTries < 2) {
or/config.c:  } else if (options->TestingMicrodescMaxDownloadTries > 800) {
or/config.c:  if (options->TestingCertMaxDownloadTries < 2) {
or/config.c:  } else if (options->TestingCertMaxDownloadTries > 800) {
or/config.c:  if (options->TestingTorNetwork) {
or/config.c:  if (options->AccelName && !options->HardwareAccel)
or/config.c:    options->HardwareAccel = 1;
or/config.c:  if (options->AccelDir && !options->AccelName)
or/config.c:  if (options->PublishServerDescriptor)
or/config.c:    SMARTLIST_FOREACH(options->PublishServerDescriptor, const char *, pubdes, {
or/config.c:        if (smartlist_len(options->PublishServerDescriptor) > 1) {
or/config.c:  if (options->BridgeRelay == 1 && ! options->ORPort_set)
or/config.c:  if (!opt_streq(old_options->DataDirectory, new_options->DataDirectory) ||
or/config.c:      old_options->NumCPUs != new_options->NumCPUs ||
or/config.c:      !config_lines_eq(old_options->ORPort_lines, new_options->ORPort_lines) ||
or/config.c:      old_options->ServerDNSSearchDomains !=
or/config.c:                                       new_options->ServerDNSSearchDomains ||
or/config.c:      old_options->SafeLogging_ != new_options->SafeLogging_ ||
or/config.c:      old_options->ClientOnly != new_options->ClientOnly ||
or/config.c:      !config_lines_eq(old_options->Logs, new_options->Logs) ||
or/config.c:      old_options->LogMessageDomains != new_options->LogMessageDomains)
or/config.c:  if (!opt_streq(old_options->DataDirectory, new_options->DataDirectory) ||
or/config.c:      !opt_streq(old_options->Nickname,new_options->Nickname) ||
or/config.c:      !opt_streq(old_options->Address,new_options->Address) ||
or/config.c:      !config_lines_eq(old_options->ExitPolicy,new_options->ExitPolicy) ||
or/config.c:      old_options->ExitPolicyRejectPrivate !=
or/config.c:        new_options->ExitPolicyRejectPrivate ||
or/config.c:      old_options->IPv6Exit != new_options->IPv6Exit ||
or/config.c:      !config_lines_eq(old_options->ORPort_lines,
or/config.c:                       new_options->ORPort_lines) ||
or/config.c:      !config_lines_eq(old_options->DirPort_lines,
or/config.c:                       new_options->DirPort_lines) ||
or/config.c:      old_options->ClientOnly != new_options->ClientOnly ||
or/config.c:      old_options->DisableNetwork != new_options->DisableNetwork ||
or/config.c:      old_options->PublishServerDescriptor_ !=
or/config.c:        new_options->PublishServerDescriptor_ ||
or/config.c:      !opt_streq(old_options->ContactInfo, new_options->ContactInfo) ||
or/config.c:      !opt_streq(old_options->MyFamily, new_options->MyFamily) ||
or/config.c:      !opt_streq(old_options->AccountingStart, new_options->AccountingStart) ||
or/config.c:      old_options->AccountingMax != new_options->AccountingMax ||
or/config.c:  newoptions->magic_ = OR_OPTIONS_MAGIC;
or/config.c:  newoptions->command = command;
or/config.c:  newoptions->command_arg = command_arg;
or/config.c:  if (newoptions->TestingTorNetwork) {
or/config.c:    newoptions->magic_ = OR_OPTIONS_MAGIC;
or/config.c:    newoptions->command = command;
or/config.c:    newoptions->command_arg = command_arg;
or/config.c:  for (opt = options->AddressMap; opt; opt = opt->next) {
or/config.c:               options->RunAsDaemon;
or/config.c:  if (options->LogTimeGranularity <= 0) {
or/config.c:             options->LogTimeGranularity);
or/config.c:  } else if (1000 % options->LogTimeGranularity != 0 &&
or/config.c:             options->LogTimeGranularity % 1000 != 0) {
or/config.c:    int granularity = options->LogTimeGranularity;
or/config.c:             options->LogTimeGranularity, granularity);
or/config.c:      set_log_time_granularity(options->LogTimeGranularity);
or/config.c:  for (opt = options->Logs; opt; opt = opt->next) {
or/config.c:    logs_set_domain_logging(options->LogMessageDomains);
or/config.c:  for (cl = options->ServerTransportListenAddr; cl; cl = cl->next) {
or/config.c:  for (cl = options->ServerTransportOptions; cl; cl = cl->next) {
or/config.c:             options->SocksPort_lines, options->SocksListenAddress,
or/config.c:                        options->DNSPort_lines, options->DNSListenAddress,
or/config.c:                        options->TransPort_lines, options->TransListenAddress,
or/config.c:                        options->NATDPort_lines, options->NATDListenAddress,
or/config.c:    const int any_passwords = (options->HashedControlPassword ||
or/config.c:                               options->HashedControlSessionPassword ||
or/config.c:                               options->CookieAuthentication);
or/config.c:                          options->ControlPort_lines,
or/config.c:                          options->ControlListenAddress,
or/config.c:                                 options->ControlSocket,
or/config.c:  if (! options->ClientOnly) {
or/config.c:                          options->ORPort_lines, options->ORListenAddress,
or/config.c:                          options->ExtORPort_lines, NULL,
or/config.c:                          options->DirPort_lines, options->DirListenAddress,
or/config.c:  options->ORPort_set =
or/config.c:  options->SocksPort_set =
or/config.c:  options->TransPort_set =
or/config.c:  options->NATDPort_set =
or/config.c:  options->ControlPort_set =
or/config.c:  options->DirPort_set =
or/config.c:  options->DNSPort_set =
or/config.c:  options->ExtORPort_set =
or/config.c:      !options->BridgeRelay) {
or/config.c:  if (n_low_port && options->AccountingMax) {
or/config.c:/** Adjust the value of options->DataDirectory, or fill it in if it's
or/config.c:  if (options->DataDirectory)
or/config.c:  options->DataDirectory = p;
or/config.c:  const char *d = options->DataDirectory;
or/config.c:   if (!options->DataDirectory && !strcmp(fn,"/.tor")) {
or/config.c:   tor_free(options->DataDirectory);
or/config.c:   options->DataDirectory = fn;
or/config.c:/** Check and normalize the value of options->DataDirectory; return 0 if it
or/config.c:  tor_assert(options->DataDirectory);
or/config.c:  if (strlen(options->DataDirectory) > (512-128)) {
or/config.c:  if (options->NumCPUs == 0) {
or/config.c:    return options->NumCPUs;
or/config.c:  cfg.disable_iocp = options->DisableIOCP;
or/config.c:  cfg.msec_per_tick = options->TokenBucketRefillInterval;
or/config.c:  tor_assert(options->DataDirectory);
or/config.c:  len = strlen(options->DataDirectory);
or/config.c:                   options->DataDirectory, sub1, sub2);
or/config.c:                   options->DataDirectory, sub1);
or/config.c:    strlcpy(fname, options->DataDirectory, len);
or/config.c:  const config_line_t *lines = options->OutboundBindAddress;
or/config.c:    memset(&options->OutboundBindAddressIPv4_, 0,
or/config.c:           sizeof(options->OutboundBindAddressIPv4_));
or/config.c:    memset(&options->OutboundBindAddressIPv6_, 0,
or/config.c:           sizeof(options->OutboundBindAddressIPv6_));
or/config.c:      dst_addr = &options->OutboundBindAddressIPv4_;
or/config.c:      dst_addr = &options->OutboundBindAddressIPv6_;
or/config.c:  if (options->GeoIPFile &&
or/config.c:      ((!old_options || !opt_streq(old_options->GeoIPFile,
or/config.c:                                   options->GeoIPFile))
or/config.c:    config_load_geoip_file_(AF_INET, options->GeoIPFile, "geoip");
or/config.c:  if (options->GeoIPv6File &&
or/config.c:      ((!old_options || !opt_streq(old_options->GeoIPv6File,
or/config.c:                                   options->GeoIPv6File))
or/config.c:    config_load_geoip_file_(AF_INET6, options->GeoIPv6File, "geoip6");
or/connection.c:  if (options->ControlSocketsGroupWritable)
or/connection.c:  if (check_private_dir(p, flags, options->User) < 0) {
or/connection.c:             options->ControlSocketsGroupWritable ? " and group" : "");
or/connection.c:    if (options->User) {
or/connection.c:      pw = getpwnam(options->User);
or/connection.c:                 address, options->User);
or/connection.c:    if (options->ControlSocketsGroupWritable) {
or/connection.c:  if (options->ConstrainedSockets)
or/connection.c:    set_constrained_socket_buffers(news, (int)options->ConstrainedSockSize);
or/connection.c:        !tor_addr_is_null(&options->OutboundBindAddressIPv4_))
or/connection.c:      ext_addr = &options->OutboundBindAddressIPv4_;
or/connection.c:             !tor_addr_is_null(&options->OutboundBindAddressIPv6_))
or/connection.c:      ext_addr = &options->OutboundBindAddressIPv6_;
or/connection.c:  if (options->ConstrainedSockets)
or/connection.c:    set_constrained_socket_buffers(s, (int)options->ConstrainedSockSize);
or/connection.c:  if (options->HTTPSProxy)
or/connection.c:  else if (options->Socks4Proxy)
or/connection.c:  else if (options->Socks5Proxy)
or/connection.c:  else if (options->ClientTransportPlugin)
or/connection.c:      const char *authenticator = options->HTTPSProxyAuthenticator;
or/connection.c:      if ((options->Socks5ProxyUsername) ||
or/connection.c:  else if (! options->CountPrivateBandwidth &&
or/connection.c:      + 2*(options->RelayBandwidthRate ? options->RelayBandwidthRate :
or/connection.c:                                         options->BandwidthRate);
or/connection.c:/** Initialize the global read bucket to options-\>BandwidthBurst. */
or/connection.c:  global_read_bucket = (int)options->BandwidthBurst;
or/connection.c:  global_write_bucket = (int)options->BandwidthBurst;
or/connection.c:  if (options->RelayBandwidthRate) {
or/connection.c:    global_relayed_read_bucket = (int)options->RelayBandwidthBurst;
or/connection.c:    global_relayed_write_bucket = (int)options->RelayBandwidthBurst;
or/connection.c:    global_relayed_read_bucket = (int)options->BandwidthBurst;
or/connection.c:    global_relayed_write_bucket = (int)options->BandwidthBurst;
or/connection.c:  bandwidthrate = (int)options->BandwidthRate;
or/connection.c:  bandwidthburst = (int)options->BandwidthBurst;
or/connection.c:  if (options->RelayBandwidthRate) {
or/connection.c:    relayrate = (int)options->RelayBandwidthRate;
or/connection.c:    relayburst = (int)options->RelayBandwidthBurst;
or/connection.c:  if (options->RelayBandwidthRate) {
or/connection.c:    rate = options->RelayBandwidthRate;
or/connection.c:    burst = options->RelayBandwidthBurst;
or/connection.c:    rate = options->BandwidthRate;
or/connection.c:    burst = options->BandwidthBurst;
or/connection.c:  rate = (rate * options->TokenBucketRefillInterval) / 1000;
or/connection.c:  if (options->HTTPSProxy) {
or/connection.c:    tor_addr_copy(addr, &options->HTTPSProxyAddr);
or/connection.c:    *port = options->HTTPSProxyPort;
or/connection.c:  } else if (options->Socks4Proxy) {
or/connection.c:    tor_addr_copy(addr, &options->Socks4ProxyAddr);
or/connection.c:    *port = options->Socks4ProxyPort;
or/connection.c:  } else if (options->Socks5Proxy) {
or/connection.c:    tor_addr_copy(addr, &options->Socks5ProxyAddr);
or/connection.c:    *port = options->Socks5ProxyPort;
or/connection.c:  } else if (options->ClientTransportPlugin ||
or/connection.c:             options->Bridges) {
or/connection_edge.c:      if (seconds_since_born >= options->SocksTimeout) {
or/connection_edge.c:      if (seconds_idle >= options->SocksTimeout) {
or/connection_edge.c:                                     options->RejectPlaintextPorts, port);
or/connection_edge.c:  if (smartlist_contains_int_as_string(options->WarnPlaintextPorts, port)) {
or/connection_edge.c:  if (options->LeaveStreamsUnattached) {
or/connection_edge.c:  if (!strcmpend(socks->address, ".exit") && !options->AllowDotExit) {
or/connection_edge.c:      options->AutomapHostsOnResolve) {
or/connection_edge.c:    if (options->ClientDNSRejectInternalAddresses) {
or/connection_edge.c:    routerset_t *excludeset = options->StrictNodes ?
or/connection_edge.c:      options->ExcludeExitNodesUnion_ : options->ExcludeExitNodes;
or/connection_edge.c:    if (exit_source == ADDRMAPSRC_AUTOMAP && !options->AllowDotExit) {
or/connection_edge.c:        (exit_source == ADDRMAPSRC_NONE && !options->AllowDotExit)) {
or/connection_edge.c:    if (options->Tor2webMode) {
or/connection_edge.c:      if (options->ClientRejectInternalAddresses &&
or/connection_edge.c:                                     options->TestSocks, options->SafeSocks);
or/connection_edge.c:                                     options->TestSocks, options->SafeSocks);
or/connection_edge.c:      if (!options->AllowSingleHopExits &&
or/connection_edge.c:  if (! options->IPv6Exit) {
or/connection_edge.c:  if (routerset_contains_node(options->ExcludeExitNodesUnion_, exit)) {
or/connection_or.c:                                          !options->HTTPSProxy, now);
or/connection_or.c:    rate = (int)options->BandwidthRate;
or/connection_or.c:    burst = (int)options->BandwidthBurst;
or/connection_or.c:    rate = options->PerConnBWRate ? (int)options->PerConnBWRate :
or/connection_or.c:                                (int)options->BandwidthRate, 1, INT32_MAX);
or/connection_or.c:    burst = options->PerConnBWBurst ? (int)options->PerConnBWBurst :
or/connection_or.c:                                (int)options->BandwidthBurst, 1, INT32_MAX);
or/connection_or.c:    int64_t rate64 = (((int64_t)rate) * options->TokenBucketRefillInterval)
or/control.c:  if (!options->ControlPortWriteToFile)
or/control.c:  if (write_str_to_file(options->ControlPortWriteToFile, joined, 0) < 0) {
or/control.c:             options->ControlPortWriteToFile, strerror(errno));
or/control.c:  if (options->ControlPortFileGroupReadable) {
or/control.c:    if (chmod(options->ControlPortWriteToFile, 0640)) {
or/control.c:               options->ControlPortWriteToFile);
or/control.c:  if (!options->CookieAuthentication && !options->HashedControlPassword &&
or/control.c:      !options->HashedControlSessionPassword) {
or/control.c:  if (options->CookieAuthentication) {
or/control.c:    int also_password = options->HashedControlPassword != NULL ||
or/control.c:      options->HashedControlSessionPassword != NULL;
or/control.c:  if (options->HashedControlPassword ||
or/control.c:      options->HashedControlSessionPassword) {
or/control.c:    int also_cookie = options->CookieAuthentication;
or/control.c:    if (options->HashedControlPassword) {
or/control.c:      sl_tmp = decode_hashed_passwords(options->HashedControlPassword);
or/control.c:    if (options->HashedControlSessionPassword) {
or/control.c:      sl_tmp = decode_hashed_passwords(options->HashedControlSessionPassword);
or/control.c:    int cookies = options->CookieAuthentication;
or/control.c:      int passwd = (options->HashedControlPassword != NULL ||
or/control.c:                    options->HashedControlSessionPassword != NULL);
or/control.c:  if (options->CookieAuthFile && strlen(options->CookieAuthFile)) {
or/control.c:    return tor_strdup(options->CookieAuthFile);
or/directory.c:    if ((d->type & options->PublishServerDescriptor_) &&
or/directory.c:      if (options->StrictNodes &&
or/directory.c:          routerset_contains_routerstatus(options->ExcludeNodes, rs, -1)) {
or/directory.c:  if (!options->UseEntryGuards || !options->UseEntryGuardsAsDirGuards)
or/directory.c:  if (options->DownloadExtraInfo || options->FetchDirInfoEarly ||
or/directory.c:      options->FetchDirInfoExtraEarly || options->FetchUselessDescriptors ||
or/directory.c:      options->FetchV2Networkstatus)
or/directory.c:  if (! options->PreferTunneledDirConns)
or/directory.c:  if (options->UseBridges)
or/directory.c:  if (!options->FetchServerDescriptors && type != HIDSERV_DIRINFO)
or/directory.c:    if (options->UseBridges && type != BRIDGE_DIRINFO) {
or/directory.c:  if (options->ExcludeNodes && options->StrictNodes &&
or/directory.c:      routerset_contains_routerstatus(options->ExcludeNodes, status, -1)) {
or/directory.c:  if (!options->TunnelDirConns &&
or/directory.c:  if (!anonymized_connection && !use_begindir && !options->HTTPProxy &&
or/directory.c:      (options->Socks4Proxy || options->Socks5Proxy)) {
or/directory.c:    if (options->HTTPProxy) {
or/directory.c:      tor_addr_copy(&addr, &options->HTTPProxyAddr);
or/directory.c:      dir_port = options->HTTPProxyPort;
or/directory.c:    if (options->DisableV2DirectoryInfo_ && !is_v3) {
or/directory.c:      (!options->BridgeAuthoritativeDir &&
or/directory.c:       !options->BridgeRelay && !strcmpstart(url,"/tor/extra/"))) {
or/directory.c:  if (options->HidServDirectoryV2 &&
or/directory.c:  if (options->HSAuthoritativeDir && !strcmpstart(url,"/tor/rendezvous/")) {
or/directory.c:  if (options->BridgeAuthoritativeDir &&
or/directory.c:      options->BridgePassword_AuthDigest_ &&
or/directory.c:                   options->BridgePassword_AuthDigest_, DIGEST256_LEN)) {
or/directory.c:    if (options->BridgeAuthoritativeDir ||
or/directory.c:  if (options->HidServDirectoryV2 &&
or/directory.c:  if (options->HSAuthoritativeDir &&
or/dirserv.c:    if (options->NamingAuthoritativeDir) {
or/dirserv.c:  } else if (options->AssumeReachable) {
or/dirserv.c:              (options->AuthDirHasIPv6Connectivity != 1 ||
or/dirserv.c:  if (options->FetchDirInfoEarly)
or/dirserv.c:  if (options->BridgeRelay == 1)
or/dirserv.c:  if (!options->DirPort_set && !refuseunknown)
or/dirserv.c:  return options->UseBridges != 0;
or/dirserv.c:  return options->DirPort_set;
or/dirserv.c:  return options->DirPort_set || options->BridgeRelay;
or/dirserv.c:  if (options->BridgeRelay || options->DirPort_set)
or/dirserv.c:  return options->BridgeRelay != 0 || options->DirPort_set;
or/dirserv.c:  return options->DirPort_set;
or/dirserv.c:         !options->FetchUselessDescriptors &&
or/dirserv.c:  if (options->TestingTorNetwork) {
or/dirserv.c:    min_bw_kb = (int64_t)options->TestingMinExitFlagThreshold / 1000;
or/dirserv.c:     options->MinMeasuredBWsForAuthToIgnoreAdvertised) ? 1 : 0;
or/dirserv.c:    if (options->TestingTorNetwork) {
or/dirserv.c:      min_fast = (int32_t)options->TestingMinFastFlagThreshold;
or/dirserv.c:  if (options->AuthDirFastGuarantee &&
or/dirserv.c:      fast_bandwidth_kb > options->AuthDirFastGuarantee/1000)
or/dirserv.c:    fast_bandwidth_kb = (uint32_t)options->AuthDirFastGuarantee/1000;
or/dirserv.c:  int max_with_same_addr = options->AuthDirMaxServersPerAddr;
or/dirserv.c:  int max_with_same_addr_on_authority = options->AuthDirMaxServersPerAuthAddr;
or/dirserv.c:      ((options->AuthDirGuardBWGuarantee &&
or/dirserv.c:        routerbw_kb >= options->AuthDirGuardBWGuarantee/1000) ||
or/dirserv.c:  if (options->AuthDirHasIPv6Connectivity == 1 &&
or/dirserv.c:  int naming = options->NamingAuthoritativeDir;
or/dirserv.c:  int listbadexits = options->AuthDirListBadExits;
or/dirserv.c:  int listbaddirs = options->AuthDirListBadDirs;
or/dirserv.c:  int vote_on_hsdirs = options->VoteOnHidServDirectoriesV2;
or/dirserv.c:  if (options->VersioningAuthoritativeDir) {
or/dirserv.c:    client_versions = format_versions_list(options->RecommendedClientVersions);
or/dirserv.c:    server_versions = format_versions_list(options->RecommendedServerVersions);
or/dirserv.c:  if (options->V3BandwidthsFile) {
or/dirserv.c:    dirserv_read_measured_bandwidths(options->V3BandwidthsFile, NULL);
or/dirserv.c:  if (options->V3BandwidthsFile) {
or/dirserv.c:    dirserv_read_measured_bandwidths(options->V3BandwidthsFile,
or/dirserv.c:      last_consensus_interval = options->TestingV3AuthInitialVotingInterval;
or/dirserv.c:                                      options->TestingV3AuthVotingStartOffset);
or/dirserv.c:  if (options->ConsensusParams) {
or/dirserv.c:                           options->ConsensusParams, NULL, 0, 0);
or/dirserv.c:  voter->nickname = tor_strdup(options->Nickname);
or/dirserv.c:  if (options->V3AuthUseLegacyKey) {
or/dirserv.c:  int naming = options->NamingAuthoritativeDir;
or/dirserv.c:  int versioning = options->VersioningAuthoritativeDir;
or/dirserv.c:  int listbaddirs = options->AuthDirListBadDirs;
or/dirserv.c:  int listbadexits = options->AuthDirListBadExits;
or/dirserv.c:  int vote_on_hsdirs = options->VoteOnHidServDirectoriesV2;
or/dirserv.c:  client_versions = format_versions_list(options->RecommendedClientVersions);
or/dirserv.c:  server_versions = format_versions_list(options->RecommendedServerVersions);
or/dirserv.c:  contact = options->ContactInfo;
or/dirserv.c:                         options->Nickname);
or/dirserv.c:    if (options->BridgeAuthoritativeDir && by_fp) {
or/dirvote.c:  timing_out->vote_interval = options->V3AuthVotingInterval;
or/dirvote.c:  timing_out->n_intervals_valid = options->V3AuthNIntervalsValid;
or/dirvote.c:  timing_out->vote_delay = options->V3AuthVoteDelay;
or/dirvote.c:  timing_out->dist_delay = options->V3AuthDistDelay;
or/dirvote.c:    interval = options->TestingV3AuthInitialVotingInterval;
or/dirvote.c:    vote_delay = options->TestingV3AuthInitialVoteDelay;
or/dirvote.c:    dist_delay = options->TestingV3AuthInitialDistDelay;
or/dirvote.c:                                      options->TestingV3AuthVotingStartOffset);
or/dirvote.c:                                      options->TestingV3AuthVotingStartOffset);
or/dns.c:  return options->ServerDNSTestAddresses &&
or/dns.c:    smartlist_contains_string_case(options->ServerDNSTestAddresses, address);
or/dns.c: * options->ServerDNSResolvConfFile; on Windows, this reads from
or/dns.c: * options->ServerDNSResolvConfFile or the registry.  Return 0 on success or
or/dns.c:  conf_fname = options->ServerDNSResolvConfFile;
or/dns.c:  if (! tor_addr_is_null(&options->OutboundBindAddressIPv4_)) {
or/dns.c:    socklen = tor_addr_to_sockaddr(&options->OutboundBindAddressIPv4_, 0,
or/dns.c:  if (options->ServerDNSRandomizeCase)
or/dns.c:  if (options->DisableNetwork)
or/dns.c:  if (options->ServerDNSTestAddresses) {
or/dns.c:    SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
or/entrynodes.c:  else if (options->UseBridges && (!node->ri ||
or/entrynodes.c:  else if (options->UseBridges && !node_is_a_configured_bridge(node))
or/entrynodes.c:  else if (!options->UseBridges && !node->is_possible_guard &&
or/entrynodes.c:           !routerset_contains_node(options->EntryNodes,node))
or/entrynodes.c:  else if (routerset_contains_node(options->ExcludeNodes, node))
or/entrynodes.c:    if (options->UseBridges && node_is_a_configured_bridge(node))
or/entrynodes.c:  if (routerset_contains_node(options->EntryNodes, node)) {
or/entrynodes.c:        if (n++ == options->NumEntryGuards) {
or/entrynodes.c:  if (for_directory && options->NumDirectoryGuards != 0)
or/entrynodes.c:    return options->NumDirectoryGuards;
or/entrynodes.c:  return options->NumEntryGuards;
or/entrynodes.c:  if (options->GuardLifetime >= 1) {
or/entrynodes.c:                 options->GuardLifetime,
or/entrynodes.c:  if (options->EntryNodes) /* reshuffle the entry guard list if needed */
or/entrynodes.c:  if (!options->EntryNodes) {
or/entrynodes.c:    char *string = routerset_to_string(options->EntryNodes);
or/entrynodes.c:  routerset_get_all_nodes(entry_nodes, options->EntryNodes,
or/entrynodes.c:                          options->ExcludeNodes, 0);
or/entrynodes.c:    } else if (routerset_contains_node(options->ExcludeNodes, node)) {
or/entrynodes.c:    if (smartlist_len(entry_guards) > options->NumEntryGuards * 10)
or/entrynodes.c:  if (options->EntryNodes)
or/entrynodes.c:  if (options->UseBridges)
or/entrynodes.c:      if (options->EntryNodes &&
or/entrynodes.c:          !routerset_contains_node(options->EntryNodes, node)) {
or/entrynodes.c:        if (options->StrictNodes) {
or/entrynodes.c:  if (routerset_contains_bridge(options->ExcludeNodes, bridge)) {
or/entrynodes.c:      if (routerset_contains_bridge(options->ExcludeNodes, bridge)) {
or/entrynodes.c:                            !options->UpdateBridgesFromAuthority;
or/entrynodes.c:                !options->UpdateBridgesFromAuthority, !num_bridge_auths);
or/entrynodes.c:  int need_bridges = options->UseBridges != 0;
or/ext_orport.c:  if (options->ExtORPortCookieAuthFile &&
or/ext_orport.c:      strlen(options->ExtORPortCookieAuthFile)) {
or/ext_orport.c:    return tor_strdup(options->ExtORPortCookieAuthFile);
or/geoip.c:  return options->BridgeRelay && options->BridgeRecordUsageByCountry;
or/geoip.c:    if (!options->EntryStatistics &&
or/geoip.c:        (!(options->BridgeRelay && options->BridgeRecordUsageByCountry)))
or/geoip.c:    if (options->BridgeRelay || options->BridgeAuthoritativeDir ||
or/geoip.c:        !options->DirReqStatistics)
or/hibernate.c: * options->AccountingStart.  Return 0 on success, -1 on failure. If
or/hibernate.c:  const char *v = options->AccountingStart;
or/hibernate.c:  if (options->AccountingMax)
or/hibernate.c:  uint64_t max_configured = (options->RelayBandwidthRate > 0 ?
or/hibernate.c:                             options->RelayBandwidthRate :
or/hibernate.c:                             options->BandwidthRate) * 60;
or/hibernate.c:               "again to exit now.", options->ShutdownWaitLength);
or/hibernate.c:    shutdown_time = time(NULL) + options->ShutdownWaitLength;
or/main.c:    if (options->DownloadExtraInfo)
or/main.c:    now >= conn->timestamp_lastwritten + options->KeepalivePeriod;
or/main.c:            + options->TestingDirConnectionMaxStall < now) ||
or/main.c:            + options->TestingDirConnectionMaxStall < now))) {
or/main.c:      now >= or_conn->timestamp_lastempty + options->KeepalivePeriod*10 &&
or/main.c:      now >= conn->timestamp_lastwritten + options->KeepalivePeriod*10) {
or/main.c:    if (advertised_server_mode() && !options->DisableNetwork)
or/main.c:  if (!options->DisableNetwork && time_to_try_getting_descriptors < now) {
or/main.c:  if (options->UseBridges)
or/main.c:    if (options->CellStatistics) {
or/main.c:    if (options->DirReqStatistics) {
or/main.c:    if (options->EntryStatistics) {
or/main.c:    if (options->ExitPortStatistics) {
or/main.c:    if (options->ConnDirectionStatistics) {
or/main.c:    if (options->BridgeAuthoritativeDir) {
or/main.c:    rep_history_clean(now - options->RephistTrackTime);
or/main.c:  if (time_to_check_descriptor < now && !options->DisableNetwork) {
or/main.c:  if (time_to_download_networkstatus < now && !options->DisableNetwork) {
or/main.c:  if (options->BridgeAuthoritativeDir &&
or/main.c:      options->PortForwarding &&
or/main.c:      tor_check_port_forwarding(options->PortForwardingHelper,
or/main.c:  if (options->HeartbeatPeriod &&
or/main.c:    time_to_next_heartbeat = now+options->HeartbeatPeriod;
or/main.c:  if (options->ReloadTorrcOnSIGHUP) {
or/main.c:  if (!options->DisableNetwork)
or/main.c:  if (options->command == CMD_RUN_TOR) {
or/main.c:    if (options->PidFile)
or/main.c:      unlink(options->PidFile);
or/main.c:    if (options->ControlPortWriteToFile)
or/main.c:      unlink(options->ControlPortWriteToFile);
or/microdesc.c:  int ret = options->UseMicrodescriptors;
or/microdesc.c:    if (options->UseBridges && !any_bridge_supports_microdescriptors())
or/microdesc.c:    ret = !server_mode(options) && !options->FetchUselessDescriptors;
or/microdesc.c:  if (options->FetchUselessDescriptors)
or/microdesc.c:  if (options->FetchUselessDescriptors)
or/networkstatus.c:  if (options->FetchUselessDescriptors) {
or/networkstatus.c:                             options->TestingConsensusMaxDownloadTries))
or/networkstatus.c:      if (options->FetchDirInfoExtraEarly || authdir_mode_v3(options)) {
or/networkstatus.c:  if (options->UseBridges && !any_bridge_descriptors_known()) {
or/networkstatus.c:  if (authdir_mode_any_main(options) || options->FetchV2Networkstatus)
or/networkstatus.c:               options->DataDirectory);
or/networkstatus.c:  if (!rs->is_flagged_running && !options->FetchUselessDescriptors) {
or/networkstatus.c:  if (rs->published_on + options->TestingEstimatedDescriptorPropagationTime
or/nodelist.c:      if (client && options->ClientPreferIPv6ORPort == 1 &&
or/nodelist.c:  if ((options->ClientUseIPv6 || options->UseBridges) &&
or/nodelist.c:  if (options->EnforceDistinctSubnets) {
or/nodelist.c:  if (options->NodeFamilySets) {
or/nodelist.c:    SMARTLIST_FOREACH(options->NodeFamilySets, const routerset_t *, rs, {
or/nodelist.c:  if (options->EnforceDistinctSubnets) {
or/nodelist.c:  if (options->NodeFamilySets) {
or/nodelist.c:    SMARTLIST_FOREACH(options->NodeFamilySets, const routerset_t *, rs, {
or/nodelist.c:        !routerset_contains_node(options->ExcludeExitNodesUnion_, node))
or/nodelist.c:  if (options->EntryNodes) {
or/nodelist.c:                             options->EntryNodes, 0);
or/nodelist.c:                           options->ExitNodes, 1);
or/nodelist.c:  if (options->PathsNeededToBuildCircuits >= 0.0) {
or/nodelist.c:    return options->PathsNeededToBuildCircuits;
or/onion.c:  if ((tap_usec + ntor_usec) / 1000 > (uint64_t)options->MaxOnionQueueDelay)
or/onion.c:      tap_usec / 1000 > (uint64_t)options->MaxOnionQueueDelay * 2 / 3)
or/policies.c:  if (options->ReachableDirAddresses &&
or/policies.c:      options->ReachableORAddresses &&
or/policies.c:      options->ReachableAddresses) {
or/policies.c:  if (!options->ReachableORAddresses && options->ReachableAddresses)
or/policies.c:  if (parse_addr_policy(options->ReachableORAddresses ?
or/policies.c:                          options->ReachableORAddresses :
or/policies.c:                          options->ReachableAddresses,
or/policies.c:             options->ReachableORAddresses ? "OR" : "");
or/policies.c:  if (!options->ReachableDirAddresses && options->ReachableAddresses)
or/policies.c:  if (parse_addr_policy(options->ReachableDirAddresses ?
or/policies.c:                          options->ReachableDirAddresses :
or/policies.c:                          options->ReachableAddresses,
or/policies.c:    if (options->ReachableDirAddresses)
or/policies.c:  if (policies_parse_exit_policy(options->ExitPolicy, &addr_policy,
or/policies.c:                                 options->IPv6Exit,
or/policies.c:                                 options->ExitPolicyRejectPrivate, NULL,
or/policies.c:                                 !options->BridgeRelay))
or/policies.c:  if (parse_addr_policy(options->DirPolicy, &addr_policy, -1))
or/policies.c:  if (parse_addr_policy(options->SocksPolicy, &addr_policy, -1))
or/policies.c:  if (parse_addr_policy(options->AuthDirReject, &addr_policy,
or/policies.c:  if (parse_addr_policy(options->AuthDirInvalid, &addr_policy,
or/policies.c:  if (parse_addr_policy(options->AuthDirBadDir, &addr_policy,
or/policies.c:  if (parse_addr_policy(options->AuthDirBadExit, &addr_policy,
or/policies.c:  if (parse_addr_policy(options->ReachableAddresses, &addr_policy,
or/policies.c:  if (parse_addr_policy(options->ReachableORAddresses, &addr_policy,
or/policies.c:  if (parse_addr_policy(options->ReachableDirAddresses, &addr_policy,
or/policies.c:  if (load_policy_from_option(options->SocksPolicy, &socks_policy, -1) < 0)
or/policies.c:  if (load_policy_from_option(options->DirPolicy, &dir_policy, -1) < 0)
or/policies.c:  if (load_policy_from_option(options->AuthDirReject,
or/policies.c:  if (load_policy_from_option(options->AuthDirInvalid,
or/policies.c:  if (load_policy_from_option(options->AuthDirBadDir,
or/policies.c:  if (load_policy_from_option(options->AuthDirBadExit,
or/rendclient.c:      routerset_contains_extendinfo(options->ExcludeNodes,
or/rendclient.c:  for (line = options->HidServAuth; line; line = line->next) {
or/rendservice.c:  for (line = options->RendConfigLines; line; line = line->next) {
or/rendservice.c:  if (options->StrictNodes &&
or/rendservice.c:      routerset_contains_extendinfo(options->ExcludeNodes, rp)) {
or/rendservice.c:    if (options->ExcludeNodes) {
or/rendservice.c:                                       options->ExcludeNodes, flags);
or/rephist.c:  if (options->RelayBandwidthRate) {
or/rephist.c:    cutoff = options->RelayBandwidthRate * NUM_SECS_BW_SUM_INTERVAL;
or/router.c:  int lifetime = options->SSLKeyLifetime;
or/router.c:  if (options->TLSECGroup) {
or/router.c:    if (!strcasecmp(options->TLSECGroup, "P256"))
or/router.c:    else if (!strcasecmp(options->TLSECGroup, "P224"))
or/router.c:  if (check_private_dir(options->DataDirectory, CPD_CREATE, options->User)) {
or/router.c:  if (check_private_dir(keydir, CPD_CREATE, options->User)) {
or/router.c:  if(options->ChooseFingerprint && options->DesiredFingerprint && (strlen(options->DesiredFingerprint)==40))
or/router.c:	prkey = generate_key_for_desired_fingerprint(keydir, options->DesiredFingerprint, LOG_ERR);
or/router.c:  if (options->command == CMD_RUN_TOR) {
or/router.c:      or_state_mark_dirty(state, options->AvoidDiskWrites ?
or/router.c:    if (dirserv_add_own_fingerprint(options->Nickname,
or/router.c:  tor_assert(strlen(options->Nickname) <= MAX_NICKNAME_LEN);
or/router.c:                   "%s %s\n",options->Nickname, fingerprint) < 0) {
or/router.c:      options->Nickname, fingerprint);
or/router.c:  type = ((options->V1AuthoritativeDir ? V1_DIRINFO : NO_DIRINFO) |
or/router.c:          (options->V2AuthoritativeDir ? V2_DIRINFO : NO_DIRINFO) |
or/router.c:          (options->V3AuthoritativeDir ?
or/router.c:          (options->BridgeAuthoritativeDir ? BRIDGE_DIRINFO : NO_DIRINFO) |
or/router.c:          (options->HSAuthoritativeDir ? HIDSERV_DIRINFO : NO_DIRINFO));
or/router.c:    ds = trusted_dir_server_new(options->Nickname, NULL,
or/router.c:  return options->AssumeReachable ||
or/router.c:  return !options->DirPort_set ||
or/router.c:         options->AssumeReachable ||
or/router.c:                         U64_PRINTF_ARG(options->AccountingMax),
or/router.c:        options->AccountingMax / interval_length) {
or/router.c:  } else if (options->BandwidthRate < MIN_BW_TO_ADVERTISE_DIRPORT ||
or/router.c:             (options->RelayBandwidthRate > 0 &&
or/router.c:              options->RelayBandwidthRate < MIN_BW_TO_ADVERTISE_DIRPORT)) {
or/router.c:  if (routerset_contains_router(options->ExcludeNodes, me, -1) &&
or/router.c:      options->StrictNodes) {
or/router.c:  return options->AuthoritativeDir != 0;
or/router.c:  return authdir_mode(options) && options->V1AuthoritativeDir != 0;
or/router.c:  return authdir_mode(options) && options->V2AuthoritativeDir != 0;
or/router.c:  return authdir_mode(options) && options->V3AuthoritativeDir != 0;
or/router.c:  return options->V1AuthoritativeDir ||
or/router.c:         options->V2AuthoritativeDir ||
or/router.c:         options->V3AuthoritativeDir;
or/router.c:  return options->BridgeAuthoritativeDir ||
or/router.c:    return (options->BridgeAuthoritativeDir);
or/router.c:  return authdir_mode(options) && options->BridgeAuthoritativeDir != 0;
or/router.c:  if (options->ClientOnly) return 0;
or/router.c:  return (options->ORPort_set || options->ORListenAddress);
or/router.c:  return (!options->BridgeRelay);
or/router.c:  if (options->RefuseUnknownExits != -1) {
or/router.c:    return options->RefuseUnknownExits;
or/router.c:  if (options->ClientOnly)
or/router.c:  if (options->PublishServerDescriptor_ == NO_DIRINFO)
or/router.c:  ri->nickname = tor_strdup(options->Nickname);
or/router.c:    policies_parse_exit_policy(options->ExitPolicy, &ri->exit_policy,
or/router.c:                               options->IPv6Exit,
or/router.c:                               options->ExitPolicyRejectPrivate,
or/router.c:                               ri->address, !options->BridgeRelay);
or/router.c:  if (options->IPv6Exit) {
or/router.c:  if (options->MyFamily && ! options->BridgeRelay) {
or/router.c:    smartlist_split_string(family, options->MyFamily, ",",
or/router.c:       if (!strcasecmp(name, options->Nickname))
or/router.c:    options->BridgeRelay ? ROUTER_PURPOSE_BRIDGE : ROUTER_PURPOSE_GENERAL;
or/router.c:  if (options->BridgeRelay) {
or/router.c:  if (server_mode(options) && options->PublishServerDescriptor_)
or/router.c:    log_info(LD_CONFIG,"options->Address didn't resolve into an IP.");
or/router.c:    options->DownloadExtraInfo ? "caches-extra-info\n" : "",
or/router.c:    options->HidServDirectoryV2 ? "hidden-service-dir\n" : "",
or/router.c:    options->AllowSingleHopExits ? "allow-single-hop-exits\n" : "");
or/router.c:  if (options->ContactInfo && strlen(options->ContactInfo)) {
or/router.c:    const char *ci = options->ContactInfo;
or/router.c:  if (options->ExtraInfoStatistics && write_stats_to_extrainfo) {
or/router.c:    if (options->DirReqStatistics &&
or/router.c:    if (options->EntryStatistics &&
or/router.c:    if (options->CellStatistics &&
or/router.c:    if (options->ExitPortStatistics &&
or/router.c:    if (options->ConnDirectionStatistics &&
or/router.c:  if (options->ServerTransportPlugin) {
or/routerlist.c:        routerset_contains_routerstatus(options->ExcludeNodes, status,
or/routerlist.c:  if (result == NULL && try_excluding && !options->StrictNodes && n_excluded) {
or/routerlist.c:    options->DirAuthorityFallbackRate : 1.0;
or/routerlist.c:          routerset_contains_routerstatus(options->ExcludeNodes,
or/routerlist.c:  if (result == NULL && try_excluding && !options->StrictNodes && n_excluded) {
or/routerlist.c:    !(authdir_mode_any_main(options) || options->FetchV2Networkstatus) ||
or/routerlist.c:                      options->TestingClientMaxIntervalWithoutRequest) > now;
or/routerlist.c:                          options->TestingDescriptorMaxDownloadTries)) {
or/routerlist.c:  if (!options->Address &&
or/routerlist.c:  if (! options->DownloadExtraInfo)
or/routerlist.c:                          options->TestingDescriptorMaxDownloadTries)) {
or/routerlist.c:  if (options->EntryNodes)
or/routerlist.c:    routerset_refresh_countries(options->EntryNodes);
or/routerlist.c:  if (options->ExitNodes)
or/routerlist.c:    routerset_refresh_countries(options->ExitNodes);
or/routerlist.c:  if (options->ExcludeNodes)
or/routerlist.c:    routerset_refresh_countries(options->ExcludeNodes);
or/routerlist.c:  if (options->ExcludeExitNodes)
or/routerlist.c:    routerset_refresh_countries(options->ExcludeExitNodes);
or/routerlist.c:  if (options->ExcludeExitNodesUnion_)
or/routerlist.c:    routerset_refresh_countries(options->ExcludeExitNodesUnion_);
or/transports.c:    if (options->ExtORPort_lines) {
